var documenterSearchIndex = {"docs":
[{"location":"misc/","page":"Other functions","title":"Other functions","text":"CurrentModule = AbstractPermutations","category":"page"},{"location":"misc/#Permutation-specific-functions","page":"Other functions","title":"Permutation specific functions","text":"","category":"section"},{"location":"misc/","page":"Other functions","title":"Other functions","text":"isodd(::AbstractPermutation)\niseven(::AbstractPermutation)\nsign(::AbstractPermutation)\npermtype\ncycles\nLex\nDegLex","category":"page"},{"location":"misc/#Base.isodd-Tuple{AbstractPermutations.AbstractPermutation}","page":"Other functions","title":"Base.isodd","text":"isodd(g::AbstractPermutation) -> Bool\n\nReturn true if g is an odd permutation and false otherwise.\n\nAn odd permutation decomposes into an odd number of transpositions.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Base.iseven-Tuple{AbstractPermutations.AbstractPermutation}","page":"Other functions","title":"Base.iseven","text":"isodd(g::AbstractPermutation) -> Bool\n\nReturn true if g is an even permutation and false otherwise.\n\nAn even permutation decomposes into an even number of transpositions.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Base.sign-Tuple{AbstractPermutations.AbstractPermutation}","page":"Other functions","title":"Base.sign","text":"sign(g::AbstractPermutation)\n\nReturn the sign of a permutation as an integer ±1.\n\nsign represents the homomorphism from the permutation group to the unit group of ℤ whose kernel is the alternating group.\n\n\n\n\n\n","category":"method"},{"location":"misc/#AbstractPermutations.permtype","page":"Other functions","title":"AbstractPermutations.permtype","text":"permtype(g::AbstractPermutation)\n\nReturn the group-theoretic type of permutation g, i.e. the vector of lengths of cycles in the (disjoint) cycle decomposition of g.\n\nThe lengths are sorted in decreasing order and cycles of length 1 are omitted. permtype(g) fully determines the conjugacy class of g in the full symmetric group.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractPermutations.cycles","page":"Other functions","title":"AbstractPermutations.cycles","text":"cycles(g::AbstractPermutation)\n\nReturn an iterator over cycles in the disjoint cycle decomposition of g.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractPermutations.Lex","page":"Other functions","title":"AbstractPermutations.Lex","text":"Lex <: Base.Order.Ordering\n\nLexicographical ordering of permutations.\n\nThe comparison of permutations σ and τ in Lexicographical ordering returns true when there exists k ≥ 1 such that\n\ni^σ == i^τ for all i < k and\nk^σ < k^τ\n\nand false otherwise.\n\nThe method isless(σ::AbstractPermutation, τ::AbstractPermutation) defaults to the lexicographical order, i.e. calling Base.lt(Lex(), σ, τ).\n\nSee also DegLex.\n\n\n\n\n\n","category":"type"},{"location":"misc/#AbstractPermutations.DegLex","page":"Other functions","title":"AbstractPermutations.DegLex","text":"DegLex <: Base.Order.Ordering\n\nDegree-then-lexicographical ordering of permutations.\n\nThe comparison of σ and τ is made by comparing degrees first, and by the lexicographical ordering among permutations of the same degree.\n\nSee also Lex.\n\n\n\n\n\n","category":"type"},{"location":"misc/#Function-specific-to-actions-on-1:n","page":"Other functions","title":"Function specific to actions on 1:n","text":"","category":"section"},{"location":"misc/","page":"Other functions","title":"Other functions","text":"firstmoved\nfixedpoints\nnfixedpoints","category":"page"},{"location":"misc/#AbstractPermutations.firstmoved","page":"Other functions","title":"AbstractPermutations.firstmoved","text":"firstmoved(g::AbstractPermutation, range)\n\nReturn the first point from range that is moved by g, or nothing if g fixes range point-wise.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractPermutations.fixedpoints","page":"Other functions","title":"AbstractPermutations.fixedpoints","text":"fixedpoints(g::AbstractPermutation, range)\n\nReturn the vector of points in range fixed by g.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractPermutations.nfixedpoints","page":"Other functions","title":"AbstractPermutations.nfixedpoints","text":"nfixedpoints(g::AbstractPermutation, range)\n\nReturn the number of points in range fixed by g.\n\n\n\n\n\n","category":"function"},{"location":"misc/#The-@perm-macro","page":"Other functions","title":"The @perm macro","text":"","category":"section"},{"location":"misc/","page":"Other functions","title":"Other functions","text":"@perm","category":"page"},{"location":"misc/#AbstractPermutations.@perm","page":"Other functions","title":"AbstractPermutations.@perm","text":"@perm P cycles_string\n\nMacro to parse cycles decomposition as a string into a permutation of type P.\n\nStrings for the output of e.g. GAP could be copied directly into @perm, as long as they are not elided. Cycles of length 1 are not necessary, but can be included.\n\nExamples:\n\nUsing the exemplary implementation from test/perms_by_images.jl\n\njulia> p = @perm Perm{UInt16} \"(1,3)(2,4)\"\n(1,3)(2,4)\n\njulia> typeof(p)\nPerm{UInt16}\n\njulia> q = @perm Perm \"(1,3)(2,4)(3,5)(8)\"\n(1,5,3)(2,4)\n\n\n\n\n\n\n","category":"macro"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"CurrentModule = AbstractPermutations","category":"page"},{"location":"abstract_api/#The-AbstractPermutation-interface","page":"AbstractPermutation interface","title":"The AbstractPermutation interface","text":"","category":"section"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"The AbstractPermutation interface consists of just three mandatory functions. Note that none of them is exported, hence it is safe to import/using the package without introducing any naming conflicts with other packages.","category":"page"},{"location":"abstract_api/#Mandatory-methods","page":"AbstractPermutation interface","title":"Mandatory methods","text":"","category":"section"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"The three mandatory methods are:","category":"page"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"a constructor,\nAbstractPermutations.degree and\nBase.^.","category":"page"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"note: Note\nThe meaning of degree doesn't have a well established tradition in mathematics. This is still ok, as long as we define its meaning with care for precision and use it in a consistent and predictable way.","category":"page"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"AbstractPermutation","category":"page"},{"location":"abstract_api/#AbstractPermutations.AbstractPermutation","page":"AbstractPermutation interface","title":"AbstractPermutations.AbstractPermutation","text":"AbstractPermutation\n\nAbstract type representing bijections of positive integers ℕ = {1,2,…} finitely supported. That is, we treat permutations as functions ℕ → ℕ such that for every permutation σ there are only finitely many k different from their image under σ.\n\nMandatory interface\n\nSubtypes APerm <: AbstractPermutation must implement the following functions:\n\nAPerm(images::AbstractVector{<:Integer}[; check::Bool=true]) - a constructor of a APerm from a vector of images. Optionally the keyword argument check may be set to false when the caller knows that images constitute a honest permutation.\nBase.:^(i::Integer, σ::APerm) the customary notation for the image of i under σ.\ndegree(σ::APerm) the minimal d ≥ 0 such that σ fixes all k ≥ d.\n\nnote: Note\nThere is no formal requirement that the APerm(images) constructor actually returns a APerm. Any AbstractPermutation object would do. This may be useful if constructing permutation from images is not technically feasible.\n\nnote: Note\nIf APerm is not constructable from type one needs to implement one(::APerm).\n\nwarn: Warn\nEven though AbstractPermutation <: GroupsCore.GroupElement they don't necessarily implement the whole of GroupElement interface, e.g. it is possible to implement parent-less permutations.\n\nOptional interface\n\nperm(σ::APerm) by default returns σ - the \"simplest\" (implementation-wise) permutation underlying σ.\ninttype(::Type{<:APerm}) by default returns UInt32.\n__unsafe_image(i::Integer, σ::APerm) defaults to i^σ.\n\n\n\n\n\n","category":"type"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"degree","category":"page"},{"location":"abstract_api/#AbstractPermutations.degree","page":"AbstractPermutation interface","title":"AbstractPermutations.degree","text":"degree(σ::AbstractPermutation)\n\nReturn a minimal number n ≥ 0 such that k^σ == k for all k > n.\n\nSuch number n can be understood as a degree of a permutation, since we can regard σ as an element of Sym(n) (and not of Sym(n-1)).\n\nnote: Note\nBy this convention degree of the identity permutation is equal to 0 and it is the only permutation with this property. Also by this convention there is no permutation with degree equal to 1.\n\n\n\n\n\n","category":"function"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"^(::Integer, ::AbstractPermutation)","category":"page"},{"location":"abstract_api/#Base.:^-Tuple{Integer, AbstractPermutations.AbstractPermutation}","page":"AbstractPermutation interface","title":"Base.:^","text":"^(i::Integer, σ::AbstractPermutation)\n\nReturn the image of i under σ preserving the type of i.\n\nWe consider σ as a permutation of ℕ (the positive integers), with finite support, so k^σ = k for all k > degree(σ).\n\nwarn: Warn\nThe behaviour of i^σ for i ≤ 0 is undefined and can not be relied upon.\n\n\n\n\n\n","category":"method"},{"location":"abstract_api/#Suplementary-methods","page":"AbstractPermutation interface","title":"Suplementary methods","text":"","category":"section"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"Moreover there are three internal, suplementary functions that may be overloaded by the implementer, if needed (mostly for performance reasons).","category":"page"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"inttype\nperm\n__unsafe_image","category":"page"},{"location":"abstract_api/#AbstractPermutations.inttype","page":"AbstractPermutation interface","title":"AbstractPermutations.inttype","text":"inttype(σ::Type{<:AbstractPermutation})\n\nReturn the underlying \"storage\" integer.\n\nwarn: Warn\nFor internal use only.\n\nThe intention is to provide optimal storage type when the images vector constructor is used (to save allocations and memory copy). For example a hypothetic permutation Perm8 of elements up to length 255 may alter the default to UInt8.\n\nThe default is UInt32.\n\n\n\n\n\n","category":"function"},{"location":"abstract_api/#AbstractPermutations.perm","page":"AbstractPermutation interface","title":"AbstractPermutations.perm","text":"perm(p::AbstractPermutation)\n\nReturn the \"bare-metal\" permutation (unwrap). Return σ by default.\n\nwarn: Warn\nFor internal use only.\n\nProvide access to wrapped permutation object. For \"bare-metal\" permutations this method needs to return the identical (i.e. `===) object.\n\nThe intention of this method is to provide an un-wrapped permutations to computationally intensive algorithms, so that the external wrappers (if present) do not hinder the performance.\n\n\n\n\n\n","category":"function"},{"location":"abstract_api/#AbstractPermutations.__unsafe_image","page":"AbstractPermutation interface","title":"AbstractPermutations.__unsafe_image","text":"__unsafe_image(i::Integer, σ::AbstractPermutation)\n\nThe same as i^σ, but assuming that i ∈ Base.OneTo(degree(σ)).\n\nwarn: Warn\nThe caller is responsible for checking the assumption. Failure to do so may (and probably will) lead to segfaults in the best case scenario and to silent data corruption in the worst!.\n\n\n\n\n\n","category":"function"},{"location":"abstract_api/#Example-implementation","page":"AbstractPermutation interface","title":"Example implementation","text":"","category":"section"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"For an example, very simple implementation of the AbstractPermutation interface you may find in ExamplePerms module defined in perms_by_images.jl.","category":"page"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"Here we provide an alternative implementation which keeps the internal storage at fixed length.","category":"page"},{"location":"abstract_api/#Implementing-mandatory-methods","page":"AbstractPermutation interface","title":"Implementing mandatory methods","text":"","category":"section"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"import AbstractPermutations\nstruct APerm{T} <: AbstractPermutations.AbstractPermutation\n    images::Vector{T}\n    degree::Int\n\n    function APerm{T}(images::AbstractVector{<:Integer}; check::Bool=true) where T\n        if check\n            isperm(images) || throw(ArgumentError(\"`images` vector is not a permutation\"))\n        end\n        deg = something(findlast(i->images[i] ≠ i, eachindex(images)), 0)\n        return new{T}(images, deg)\n    end\nend\nnothing # hide","category":"page"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"Above we defined permutations by storing the vector of their images together with the computed degree deg.","category":"page"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"Now we need to implement the remaining two functions which will be simple enough:","category":"page"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"AbstractPermutations.degree(p::APerm) = p.degree\nfunction Base.:^(i::Integer, p::APerm)\n    deg = AbstractPermutations.degree(p)\n    # make sure that we return something of the same type as `i`\n    return 1 ≤ i ≤ deg ? oftype(i, p.images[i]) : i\nend\nnothing # hide","category":"page"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"With this the interface is implementation is complete. To test whether the implementation follows the specification a test suite is provided:","category":"page"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"include(joinpath(pkgdir(AbstractPermutations), \"test\", \"abstract_perm_API.jl\"))\nabstract_perm_interface_test(APerm{UInt16})\nnothing # hide","category":"page"},{"location":"abstract_api/#Suplementary-Methods","page":"AbstractPermutation interface","title":"Suplementary Methods","text":"","category":"section"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"Since in APerm{T} we store images as a Vector{T}, to avoid spurious allocations we may define","category":"page"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"AbstractPermutations.inttype(::Type{APerm{T}}) where T = T","category":"page"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"There is no need to define AbstractPermutations.perm as APerm is already very low level and suitable for high performance code-paths.","category":"page"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"Finally to squeeze even more performance one could define __unsafe_image with the same semantics as n^σ under the assumption that n belongs to Base.OneTo(degree(σ)):","category":"page"},{"location":"abstract_api/","page":"AbstractPermutation interface","title":"AbstractPermutation interface","text":"@inline function AbstractPermutations.__unsafe_image(n::Integer, σ::APerm)\n    return oftype(n, @inbounds σ.images[n])\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AbstractPermutations","category":"page"},{"location":"#AbstractPermutations","page":"Home","title":"AbstractPermutations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package defines an interface for abstract permutations. The general assumptions are as follows: We consider AbstractPermutations as bijective self-maps of mathbbN = 12ldots, i.e. the positive integers which are finitely supported. That means that for every permutation sigma colon mathbbN to mathbbN there are only finitely many kin mathbbN such that the value of sigma at k is different from k.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In practical terms this means that each permutation can be uniquely determined by inspecting a vector of it's values on set 1 2 ldots n for some n. By standard mathematical convention we will denote the image of k under sigma by k^sigma, to signify that the set of bijections acts on mathbbN on the right.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the description of the julia interface see the next section.","category":"page"},{"location":"#The-packages-following-AbstractPermutation-interface","page":"Home","title":"The packages following AbstractPermutation interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PermutationGroups.jl\nPermGroups.jl (to be confirmed).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that Permutations.jl do not implement the AbstractPermutations.jl interface due to the fact that they act on integers on the left. See these comments.","category":"page"}]
}
